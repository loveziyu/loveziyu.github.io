<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>Three.js Photo Sphere</title>
  <style>
    html, body { margin: 0; height: 100%; background: #111; overflow: hidden; }
    #container { width: 100%; height: 100vh; }
    .hint {
      position: absolute;
      top: 12px; left: 12px;
      background: rgba(0,0,0,0.4);
      color: #fff; padding: 6px 10px;
      border-radius: 5px; font-size: 13px; z-index: 10;
    }
  </style>
</head>
<body>
<div id="container">
  <div class="hint">拖拽旋转 · 滚轮缩放 · 点击图片可放大</div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';

const container = document.getElementById('container');

// ------------------ 1. Scene & Camera ------------------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 2000);
camera.position.set(0, 0, 800);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

// ------------------ 2. Controls ------------------
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 300;
controls.maxDistance = 2000;

// ------------------ 3. Lighting ------------------
scene.add(new THREE.AmbientLight(0xffffff, 0.9));

// ------------------ 4. Images ------------------
const images = [
  "https://threejs.org/examples/textures/uv_grid_opengl.jpg",
  "https://threejs.org/examples/textures/flower-1.jpg",
  "https://threejs.org/examples/textures/flower-2.jpg",
  "https://threejs.org/examples/textures/flower-3.jpg",
  "https://threejs.org/examples/textures/flower-4.jpg",
  "https://threejs.org/examples/textures/flower-5.jpg",
];

const loader = new THREE.TextureLoader();
const group = new THREE.Group();
scene.add(group);

const radius = 400;
const planeSize = 140;

// Fibonacci sphere for even distribution
function fibonacciSpherePoints(n, r) {
  const points = [];
  const golden = Math.PI * (3 - Math.sqrt(5));
  for (let i = 0; i < n; i++) {
    const y = 1 - (i / (n - 1)) * 2;
    const radiusAtY = Math.sqrt(1 - y*y);
    const theta = golden * i;
    const x = Math.cos(theta) * radiusAtY;
    const z = Math.sin(theta) * radiusAtY;
    points.push(new THREE.Vector3(x*r, y*r, z*r));
  }
  return points;
}

const points = fibonacciSpherePoints(images.length, radius);

// Add planes for each image
images.forEach((src, i) => {
  loader.load(src, texture => {
    const aspect = texture.image.width / texture.image.height;
    const geo = new THREE.PlaneGeometry(planeSize*aspect, planeSize);
    const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geo, mat);

    const p = points[i];
    mesh.position.copy(p);

    // Make image face outward
    mesh.lookAt(new THREE.Vector3(0,0,0));
    mesh.rotateY(Math.PI);

    mesh.userData = { src };
    group.add(mesh);
  });
});

// ------------------ 5. Raycaster for clicking ------------------
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let popupMesh = null;

function onClick(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(group.children, false);
  if(intersects.length > 0) {
    const mesh = intersects[0].object;
    openPopup(mesh.userData.src);
  }
}
renderer.domElement.addEventListener('click', onClick);

function openPopup(src) {
  if(popupMesh) {
    scene.remove(popupMesh);
    popupMesh.geometry.dispose();
    popupMesh.material.map.dispose();
    popupMesh.material.dispose();
    popupMesh = null;
  }
  loader.load(src, tex => {
    const popupSize = Math.min(window.innerWidth*0.6, window.innerHeight*0.6);
    const aspect = tex.image.width / tex.image.height;
    const geo = new THREE.PlaneGeometry(popupSize*aspect, popupSize);
    const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
    popupMesh = new THREE.Mesh(geo, mat);
    popupMesh.position.set(0,0,camera.position.z-200);
    scene.add(popupMesh);

    setTimeout(() => window.addEventListener('click', () => {
      scene.remove(popupMesh);
      popupMesh.geometry.dispose();
      popupMesh.material.map.dispose();
      popupMesh.material.dispose();
      popupMesh = null;
    }, { once: true }), 50);
  });
}

// ------------------ 6. Animation ------------------
let lastTime = performance.now();
function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = (now - lastTime)/1000;
  lastTime = now;

  // Slight auto-rotation
  group.rotation.y += 0.05*delta;

  controls.update();
  renderer.render(scene, camera);
}
animate();

// ------------------ 7. Resize ------------------
window.addEventListener('resize', () => {
  camera.aspect = container.clientWidth/container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});

</script>
</body>
</html>
